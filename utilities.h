#pragma config(Hubs,  S4, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     sonar,          sensorSONAR)
#pragma config(Sensor, S3,     color,          sensorColorNxtFULL)
#pragma config(Motor,  motorB,          spinnerA,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          spinnerB,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S4_C1_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     collector,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     front_right,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     front_left,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C4_1,     back_right,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C4_2,     back_left,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C2_1,    hook1,                tServoStandard)
#pragma config(Servo,  srvo_S4_C2_2,    hook2,                tServoStandard)
#pragma config(Servo,  srvo_S4_C2_3,    spinner1,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C2_4,    spinner2,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C2_5,    door,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "constants.h"

void driveForward(int speed, int distance)
{
	if (distance != -1) {
		nMotorEncoder[front_right] = 0;
		nMotorEncoder[front_left] = 0;
		nMotorEncoder[back_right] = 0;
		nMotorEncoder[back_left] = 0;

		motor[front_left] = speed;
		motor[back_left] = speed;
		motor[front_right] = -speed;
		motor[back_right] = -speed;

		while ((abs(nMotorEncoder[front_left]) + abs(nMotorEncoder[front_right]))
			< (2 * distance)) { }

		motor[front_left] = 0;
		motor[back_left] = 0;
		motor[front_right] = 0;
		motor[back_right] = 0;
	}
	else { //no specified distance
		motor[front_left] = speed;
		motor[back_left] = speed;
		motor[front_right] = -speed;
		motor[back_right] = -speed;
	}
}


void driveBackward(int speed, int distance)
{
	if (distance != -1) {
		nMotorEncoder[front_right] = 0;
		nMotorEncoder[front_left] = 0;
		nMotorEncoder[back_right] = 0;
		nMotorEncoder[back_left] = 0;

		motor[front_left] = -speed;
		motor[back_left] = -speed;
		motor[front_right] = speed;
		motor[back_right] = speed;

		while ((abs(nMotorEncoder[front_left]) + abs(nMotorEncoder[front_right]))
			< (2 * distance)) { }

		motor[front_left] = 0;
		motor[back_left] = 0;
		motor[front_right] = 0;
		motor[back_right] = 0;
	}
	else { //no specified distance
		motor[front_left] = -speed;
		motor[back_left] = -speed;
		motor[front_right] = speed;
		motor[back_right] = speed;
	}
}


void turnRight(int speed, int distance)
{
	nMotorEncoder[front_right] = 0;


	motor[front_right] = speed;
	motor[back_right] = speed;

	while (abs(nMotorEncoder[front_right]) < (distance)) {}

	motor[front_right] = 0;
	motor[back_right] = 0;

}

void turnLeft(int speed, int distance)
{
	nMotorEncoder[front_left] = 0;

	motor[front_left] = speed;
	motor[back_left] = speed;

	while (abs(nMotorEncoder[front_left]) + abs(nMotorEncoder[back_left]) < (2 * distance)) {}

	motor[front_left] = 0;
	motor[back_left] = 0;

}

void point_turn(int speed, int distance, int direction)
{
	nMotorEncoder[front_left] = 0;
	nMotorEncoder[front_right] = 0;
	nMotorEncoder[back_left] = 0;
	nMotorEncoder[back_right] = 0;


	motor[front_left] = direction * speed;
	motor[back_left] = direction * speed;
	motor[front_right] = direction* speed;
	motor[back_right] = direction * speed;

	while (abs(nMotorEncoder[front_left]) + abs(nMotorEncoder[front_right])
			< (2 * distance)) { }


	motor[front_left] = 0;
	motor[back_left] = 0;
	motor[front_right] = 0;
	motor[back_right] = 0;

}

void point_turn_time(int direction, int time)
{
	nMotorEncoder[front_left] = 0;
	nMotorEncoder[front_right] = 0;
	nMotorEncoder[back_left] = 0;
	nMotorEncoder[back_right] = 0;


	motor[front_left] = direction * 100;
	motor[back_left] = direction * 100;
	motor[front_right] = direction* 100;
	motor[back_right] = direction * 100;

	clearTimer(T1);

	while (time1[T1] < time) {
		motor[front_left] = direction * 100;
		motor[back_left] = direction * 100;
		motor[front_right] = direction* 100;
		motor[back_right] = direction * 100;
	}

	motor[front_left] = 0;
	motor[back_left] = 0;
	motor[front_right] = 0;
	motor[back_right] = 0;
}


void raiseLift(int height)
{
	nMotorEncoder[lift] = 0;
		while (abs(nMotorEncoder[lift]) < (height))  {
			motor[lift] = -75;
		}
		motor[lift] = 0;
		nMotorEncoder[lift] = 0;
}

void lowerLift(int height)
{
	nMotorEncoder[lift] = 0;
		while (abs(nMotorEncoder[lift]) < (height))  {
			motor[lift] = 40;
		}
		motor[lift] = 0;
		nMotorEncoder[lift] = 0;
}

void depositBall()
{
	servo[door] = DOOR_DOWN;
	wait1Msec(3000);
	servo[door] = DOOR_UP;
}

void clamp()
{
	servo[hook1] = 140;
    servo[hook2] = 90;
}

void stop()
{
	motor[front_left] = 0;
	motor[front_right] = 0;
	motor[back_left] = 0;
	motor[back_right] = 0;
}

void runCollector()
{
	clearTimer(T1);
	while (time10[T1] < 200) {
		motor[collector] = 100;
	}
	motor[collector] = 0;
}
