#pragma config(Hubs,  S4, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorB,          spinnerA,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          spinnerB,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S4_C1_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     front_right,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     front_left,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C4_1,     back_right,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C4_2,     back_left,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C2_1,    hook,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C2_2,    hook,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C2_3,    spinner1,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C2_4,    spinner2,             tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C2_5,    door,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "utilities.h"
#include "tasks.h"
#include "constants.h"


//implement state machine for autonomous
void runAutonomous(int instructions[]) {
	bool done = false;

	while (!done) {

		int i = 0;

		int state = instructions[i];
		int nextState = instructions[i+1];

		if (state == RAMP_STARTING) {
			switch(nextState) {
				case TUBE_SCORE:
					score_ball_tube(RAMP_STARTING);
					break;
				case CENTER_SCORE:
					score_ball_center(RAMP_STARTING);
					break;
				case STOP:
					stop();
					done = true;
					break;
			}
			i++;
		}
		else if (state == PARKING_STARTING) {
			switch(nextState) {
				case TUBE_SCORE:
					score_ball_tube(PARKING_STARTING);
					break;
				case CENTER_SCORE:
					score_ball_center(PARKING_STARTING);
					break;
				case STOP:
					stop();
					done = true;
					break;
			}
			i++;
		}
		else if (state == TUBE_SCORE) {
			switch(nextState) {
				case KICKSTAND:
					break;
				case TOW:
					break;
				case STOP:
					stop();
					done = true;
					break;
			}
			i++;
		}
		else if (state == CENTER_SCORE) {
			switch(nextState) {
				case KICKSTAND:
					break;
				case TOW:
					break;
				case STOP:
					stop();
					done = true;
					break;
			}
			i++;
		}
		else if (state == KICKSTAND) {
			switch(nextState) {
				case PARKING_END:
					done = true;
					break;
				case STOP:
					stop();
					done = true;
					break;
			}
		}
		else if (state == TOW) {
			switch(nextState) {
				case PARKING_END:
					done = true;
					break;
				case STOP:
					stop();
					done = true;
					break;
			}
		}
	}
}

task main()
{

	int instructions[4]; //will hold instructions for running autonomous

	eraseDisplay();

	displayOptionsMenu(instructions); //display options menu

	waitForStart();

	runAutonomous(instructions);

}