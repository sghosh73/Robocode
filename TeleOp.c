#pragma config(Hubs,  S4, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorB,          spinnerA,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          spinnerB,      tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S4_C2_1,     back_right,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     front_right,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_1,     front_left,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C3_2,     back_left,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    director1,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C1_2,    director2,            tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C1_3,    lift1,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C1_4,    lift2,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C1_5,    door,                 tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"

#define FIRST_LEVEL
#define SECOND_LEVEL
#define THIRD_LEVEL

/*
Drive configuration:

	   Front
	  _______
  1 O|       |O 2
	 |       |
	 |       |
	 |       |
  3 O|_______|O 4

  1: cos(theta-PI/4)
  2: cos(theta+PI/4)
  3: cos(theta+PI/4)
  4: cos(theta-PI/4)

  Positive rotation is forward
*/
void HoloDrive()
{
	getJoystickSettings(joystick);

	int threshold = 20; //minimum value of joystick before activating drive

	int x = joystick.joy1_x1;
	int y = -1*joystick.joy1_y1; //y is inverted

	int rot = joystick.joy1_x2;
	int rotL;
	int rotR;

	float angle = atan2(y,x);

	if (rot > 20){
		rotL=50;
		rotR=-50;
    }
    else if (rot <= 20){
  	    rotL = -50;
  	    rotR = 50;
    }
    else {
  	    rotL = 0;
  	    rotR = 0;
    }

	float length = sqrt(pow(x,2)+pow(y,2));

	if (length < threshold){
		length = 0;
    }

	int f_left = 0.78*cos(angle+(PI/4)+(PI/2))*length+rotL;
	int f_right = 0.78*cos(angle-(PI/4)+(PI/2))*length+rotL;
	int b_left = 0.78*cos(angle-(PI/4)+(PI/2))*length+rotR;
	int b_right = 0.78*cos(angle+(PI/4)+(PI/2))*length+rotR;

	motor[front_left] = f_left;
	motor[front_right] = f_right;
	motor[back_left] = b_left;
	motor[back_right] = b_right;

	//nxtDisplayBigTextLine(3, "X: %d Y: %d", x, y);
}

void TankDrive()
{
	getJoystickSettings(joystick);			 // Allows use of Joysticks

	int leftspeed = joystick.joy1_y1;
 	int rightspeed = joystick.joy1_y2;
  	int threshold = 20;

	if (abs(leftspeed) < threshold) { 
		motor[front_left] = 0; 
		motor[back_left] = 0;
	}
	else { 
		motor[front_left] = leftspeed; 
		motor[back_left] = leftspeed;
	}

	if (abs(rightspeed) < threshold) { 
		motor[front_left] = 0; 
		motor[back_left] = 0;
	}
	else { 
		motor[front_left] = rightspeed; 
		motor[back_left] = rightspeed;
	}
}

task main()
{
	motor[spinnerA] = 0;
  	motor[spinnerB] = 0;

	servo[director1] = 128;
	servo[director2] = 128;

	bool switcher = false;
	bool isPressed = false;

	while (true) {

		if(joy1Btn(01) && !isPressed){
			if (switcher){
			   switcher = false;
		   	}
		   else {
		     switcher = true;
		   }
		   isPressed = true;
		}
		if (!joy1Btn(01) && isPressed) {
    		isPressed = false;
    	}
		if (!switcher) {
         	HoloDrive();
		}
    	else {
    		TankDrive();
    	}

		getJoystickSettings(joystick);

		//stops spinners
		if (joy1Btn(5)) {
			motor[spinnerA] = 0;
			motor[spinnerB] = 0;

			servo[director1] = 128;
			servo[director2] = 128;
		}

		//spins spinner
		if (joy1Btn(7)) {
			motor[spinnerA] = -100;
			motor[spinnerB] = -100;

			servo[director1] = 100;
			servo[director2] = 200;
		}


		if (joy1Btn(1)) {
			servo[lift1] = 255;
			servo[lift2] = 0;
		}
		else if (joy1Btn(3)) {
			servo[lift1] = 0;
			servo[lift2] = 255;
		}
		else {
			servo[lift1] = 128;
			servo[lift2] = 128;
		}

		if (joy1Btn(6)) {
			servo[door] = 100;
		}

	}
}
